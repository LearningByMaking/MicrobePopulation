;jlogo file for BasicBoard written by: ANONYMOUS


to microPop
 	print "|starting microPop| 
	make "fileName exec "|sh genFileName.sh|
	make "valid 1
	make "rsync "|sh datasync_mfc.sh|		
	init-microPop 	
	wait 5 * 60 * 30
	loop 
 	[	
		prfopen :fileName
		make "dataline now	
		print "___________________________
		talkto 16 		
		see-packet
		talkto 17
		see-packet
		talkto 18
		see-packet
		talkto 19
		see-packet
		talkto 20
		see-packet
		if(:valid = 1)
		[
		   prfprint :dataline
		]		
		prfclose
		wait 10
		ignore exec :rsync                
		wait 10 * 60 * 30
		
 	]
 end
 
to init-microPop
  init-calibration
  stop-all
  wait 12
  ul-power-all
  wait 12
  ul-init-all
  wait 12
  ul-go-all
  make "resistance 3300
end

to stop-all
	talkto 16
	stopvm
	talkto 17
	stopvm
	talkto 18
	stopvm
	talkto 19
	stopvm
	talkto 20
	stopvm
end

to ul-power-all
	talkto 16
	ul-power
	talkto 17
	ul-power
	talkto 18
	ul-power
	talkto 19
	ul-power
	talkto 20
	ul-power
end

to ul-init-all
	talkto 16
	ul-init
	talkto 17
	ul-init
	talkto 18
	ul-init
	talkto 19
	ul-init
	talkto 20
	ul-init
end

to ul-go-all
	talkto 16
	ul-go
	talkto 17
	ul-go
	talkto 18
	ul-go
	talkto 19
	ul-go
	talkto 20
	ul-go
end

to init-calibration
  make "volt_cal [0 0 4095 3.3]      ; pairs (adc,volt)
end

to see-packet 
  make "packet-bytes collect-packet  
  ifelse((count :packet-bytes) > 0)
  [
  	process-header
  ]     
  [
	make "valid 0	
  ]	 
end


to process-header 
	
        let [length (first :packet-bytes) / 2 ]  
	let [nws :length + 1] 
	make "check wnth :nws :packet-bytes  			   
	make "type nth 1 :packet-bytes	
	if (:type = 55) 
	[ 
		process-data-packet		
	] 	
	make "oldcheck :check 

end

to process-data-packet
	
 
   	make "Volt0 wnth 4 :packet-bytes 
   	make "Volt0 calibrate :Volt0 :volt_cal 
	make "Power0 round voltageToPower :Volt0 :resistance
	
	make "Volt1 wnth 5 :packet-bytes 
   	make "Volt1 calibrate :Volt1 :volt_cal
	make "Power1 round voltageToPower :Volt1 :resistance	  
  
	make "Volt2 wnth 6 :packet-bytes 
  	make "Volt2 calibrate :Volt2 :volt_cal  
	make "Power2 round voltageToPower :Volt2 :resistance	  
  
	make "Volt3 wnth 7 :packet-bytes 
  	make "Volt3 calibrate :Volt3 :volt_cal
	make "Power3 round voltageToPower :Volt3 :resistance
  
	make "Volt4 wnth 8 :packet-bytes 
	make "Volt4 calibrate :Volt4 :volt_cal
	make "Power4 round voltageToPower :Volt4 :resistance 
  
	make "Volt5 wnth 9 :packet-bytes 
   	make "Volt5 calibrate :Volt5 :volt_cal 
	make "Power5 round voltageToPower :Volt5 :resistance
 
   	make "Volt6 wnth 10 :packet-bytes 
  	make "Volt6 calibrate :Volt6 :volt_cal 
	make "Power6 round voltageToPower :Volt6 :resistance
 
 	make "Volt7 wnth 11 :packet-bytes 
   	make "Volt7 calibrate :Volt7 :volt_cal 
	make "Power7 round voltageToPower :Volt7 :resistance
   	
   
  
   	make "powers (se :Power0 :Power1 :Power2 :Power3 :Power4 :Power5 :Power6 :Power7)
 	make "dataline se :dataline :powers
	print :powers  	
   

end

to calibrate :n :m
  let [adc0 nth 0 :m]
  let [adc1 nth 2 :m]
  let [val0 nth 1 :m]
  let [val1 nth 3 :m]
  let [slope (:val1 - :val0) / (:adc1 - :adc0)] 
  output  ((:n - :adc0) * :slope) + :val0
end

to valueToADC :n :m
  let [val0 nth 0 :m]
  let [val1 nth 2 :m]
  let [adc0 nth 1 :m]
  let [adc1 nth 3 :m]
  let [slope (:val1 - :val0) / (:adc1 - :adc0)] 
  output  ((:n - :adc0) * :slope) + :val0
end

to voltageToPower :voltage :resistance
	output :voltage * :voltage / :resistance * 1000000
end

to plot-adc
   x-data "|Elapsed Time (seconds)| :time-list ;
   y-data "|ADC reading| :adc-list 
   plot 2 
   display "|-geometry 600x400+1000+100|  
end

to elapsedTime
   output  int ( now / 1000 ) - :start-time ;find differerence between current time and start time
end

to addTimeToList :time
  make "time-list (se :time-list :time) 
end

to addADCToList :adc
  make "adc-list (se :adc-list :adc) 
end

to collect-packet
   output rl $1fc0 30
end

to print-packet
  make "wp packet-words :packet-bytes
  print ( se word "T bf 100 + :type round now / 1000 :wp  ) 
end

to ignore :x
end
